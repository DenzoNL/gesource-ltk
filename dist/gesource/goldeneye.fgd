//-------------------------------------------------------------------------
//
// Game data for Goldeneye Source
//
//-------------------------------------------------------------------------

@include "base.fgd"

//---------------------
// GES Player Spawners
//---------------------
@PointClass base(PlayerClass, Angles, EnableDisable, Targetname) studio("models/editor/player_deathmatch.mdl") = info_player_deathmatch :
	"This entity indicates the position and facing direction at which the player will spawn during a deathmatch map. Any number of "+
	"info_player_deathmatch entities may be placed in a map."
[
	desirability(float) : "Desirability" : 1 : "Base spawn desirability gets multiplied by this amount.  Spawns far away from the map or with few escape routes should be given a value between 1 and 0.5, spawns near good weapons or with many escape routes should be given a value between 1.2 and 1"
	ResetOnNewRound(choices) : "Reset on new round" : 1 : "Should the spawner reset its enabled state at the start of the round?"=
	[
		0 : "No"
		1 : "Yes"
	]	
	input Toggle(void) : "Toggle this player spawn on/off"
	input EnableResetting(void) : "Enable round start reset behaviour"
	input DisableResetting(void) : "Disable round start reset behaviour"
	
	spawnflags(flags)  =
	[
		1: "Don't let Bots spawn here" : 0
	]
]
@PointClass base(info_player_deathmatch) studio("models/editor/player_deathmatch_mi6.mdl") color(78 158 248) = info_player_mi6 :
	"MI6 spawn point, refer to info_player_deathmatch for more information"
[
]
@PointClass base(info_player_deathmatch) studio("models/editor/player_deathmatch_janus.mdl") color(228 41 20) = info_player_janus :
	"Janus spawn point, refer to info_player_deathmatch for more information"
[
]
@PointClass base(info_player_deathmatch) studio("models/editor/player_spectator.mdl") color(230 255 230) = info_player_spectator :
	"Spectator mode spawning, f.e. when a user first enters the game, he is placed here for viewing."
[
]

//---------------------
// GES Precipitation
//---------------------

@SolidClass base(func_precipitation) = func_GE_precipitation : 
	"A brush entity that creates rain and snow inside its volume."
[
	endsize(integer) : "End Size (0-10)" : 0
	fallspeed(float) : "Fall Speed (1-10)" : "1.5"
]

//---------------------
// GES Gameplay
//---------------------

@PointClass iconsprite("editor/gameplayinfo.vmt") base(Targetname) = ge_gameplayinfo : 
	"Use this to trigger whatever you want, a good example is closing off parts of " +
	"a level if a certain number of players are in the game. Or reconfiguring a level " +
	"dynamically for teamplay. TeamplayOn/Off are automatically triggered when it occurs. " +
	"You have to use the GetPlayerCount and GetRoundCount inputs to get output from them."
[
	FloorHeight(float) : "Floor Height" : 125 : "Minimum distance between floors in the map, Used for radar and spawning purposes." + "Do not mess with this without a reason, and try to keep it between 100 and 200."
	SpecGamemode(target_destination) : "Trigger Gamemode" : : "File name of the gamemode that fires off special outputs when loaded.  ltk, mwgg, etc."

	
	input GetConnectionCount(void) 	: "Get how many players are connected to the server"
	input GetPlayerCount(void) 	: "Get how many players are currently playing"
	input GetRoundCount(void)  	: "Get the current round number"
	
	output ConnectionCount(integer) : "Number of active players (non-spectators)"
	output PlayerCount(integer) : "Number of active players (non-spectators)"
	output RoundCount(integer)  : "Number of rounds played"
	output TeamplayOn(void) 	: "Fires when teamplay is active (on round start)"
	output TeamplayOff(void)	: "Fires when teamplay is not-active (on round start)"
	output TeamSpawnsOn(void) 	: "Fires when team spawns are active (on round start)"
	output TeamSpawnsOff(void)	: "Fires when team spawns are not-active (on round start)"
	
	output RoundStart(void)		: "Fires BEFORE players are spawned"
	output RoundEnd(void)		: "Fires when the round timer ends"
	
	output OnGameplayMatch(void) 	: "Fires when the loaded gameplay matches the Trigger Gamemode"
	output OnNoGameplayMatch(void)	: "Fires when the loaded gameplay does not match the Trigger Gamemode"
	
	output OnSuperfluousAreasEnabled(void) 	: "Fires when the gamemode wants to enable superflous areas, have this open up areas that should be sealed during modes like Living Daylights."
	output OnSuperfluousAreasDisabled(void)	: "Fires when the gamemode wants to disable superflous areas, have this close off areas that are easy to camp or get lost in."
]

//---------------------
// GES AI & SP Entities
//---------------------

@SolidClass base(func_button) studio("models/props/facility_backzone/alarm_button01a.mdl") = func_ge_alarm : 
	"An alarm trigger that NPC's and Players can use in SP"
[
	
]

//---------------------
// Respawnable Entities
//---------------------
@PointClass base(prop_physics) studioprop() sphere(fademindist) sphere(fademaxdist) = prop_physics_respawnable :
	"This class is the same as prop_physics, except it respawns after it breaks"
[

	ShouldTint(choices) : "Damage Tint" : 1 : "Should the prop darken with relation to how much health it has left every time it is damaged."=
	[
		0 : "No"
		1 : "Yes"
	]

	RespawnTime(float) : "Respawn Time" : 60 : "Ammount in seconds this prop will respawn after it breaks."
	
	// Add the bullet penetration prevention flag
	spawnflags(flags)  =
	[
		32768: "GES: Disable Penetration" : 0
	]
	
	output OnRespawn(void) : "Fires when the prop respawns."
]

@PointClass base(prop_dynamic_base,EnableDisable) sphere(fademindist) sphere(fademaxdist) studioprop() = prop_dynamic :
	"A prop that can be placed in hierarchy and can play animations. It can also be configured to break when it takes enough damage. "+
	"Note that the health of the object will be overridden by the health inside the model, to ensure consistent health game-wide. "+
	"If the model used by the prop is configured to be used as a prop_physics (i.e. it should be physically simulated) then it CANNOT be "+
	"used as a prop_dynamic. Upon level load it will display a warning in the console and remove itself. Use a prop_physics instead."
[
	ShouldTint(choices) : "Damage Tint" : 1 : "Should the prop darken with relation to how much health it has left every time it is damaged."=
	[
		0 : "No"
		1 : "Yes"
	]
	
	// Add the bullet penetration prevention flag
	spawnflags(flags)  =
	[
		32768: "GES: Disable Penetration" : 0
	]
]

@PointClass base(prop_dynamic_base) studioprop() = prop_dynamic_override :
	"A prop that can be placed in hierarchy and can play animations. It can also be configured to break when it takes enough damage.\n"+
	"prop_dynamic_override is a prototyping entity only. It will allow the use of models designed to be used as prop_physics."
[
	health(integer) : "Health" : 0 : "Number of points of damage to take before breaking.  0 means don't break."

	ShouldTint(choices) : "Damage Tint" : 1 : "Should the prop darken with relation to how much health it has left every time it is damaged."=
	[
		0 : "No"
		1 : "Yes"
	]
	
	// Add the bullet penetration prevention flag
	spawnflags(flags)  =
	[
		32768: "GES: Disable Penetration" : 0
	]
]

@PointClass base(BasePropPhysics) studioprop() sphere(fademindist) sphere(fademaxdist) = prop_physics_override :
	"A prop that physically simulates as a single rigid body. It can be constrained to other physics objects using hinges "+
	"or other constraints. It can also be configured to break when it takes enough damage. Health can be overridden on this version."
[
	health(integer) : "Health" : 0 : "Number of points of damage to take before breaking.  0 means don't break."
	
	ShouldTint(choices) : "Damage Tint" : 1 : "Should the prop darken with relation to how much health it has left every time it is damaged."=
	[
		0 : "No"
		1 : "Yes"
	]
	
	// Inputs
	input Ignite(void) : "Ignite, burst into flames."
	input IgniteLifetime(float) : "Ignite, with a parameter lifetime."
	input IgniteNumHitboxFires(integer) : "Ignite, with a parameternumber of hitbox fires."
	input IgniteHitboxFireScale(float) : "Ignite, with a parameter hitbox fire scale."

	// Add the bullet penetration prevention flag
	spawnflags(flags)  =
	[
		32768: "GES: Disable Penetration" : 0
	]
]

@PointClass base(BasePropPhysics, RenderFields) studioprop() sphere(fademindist) sphere(fademaxdist) = prop_physics :
   "A prop that physically simulates as a single rigid body. It can be constrained to other physics objects using hinges "+
   "or other constraints. It can also be configured to break when it takes enough damage. "+
   "Note that the health of the object will be overridden by the health inside the model, to ensure consistent health game-wide. "+
   "If the model used by the prop is configured to be used as a prop_dynamic (i.e. it should not be physically simulated) then it CANNOT be "+
   "used as a prop_physics. Upon level load it will display a warning in the console and remove itself. Use a prop_dynamic instead."
[

	ShouldTint(choices) : "Damage Tint" : 1 : "Should the prop darken with relation to how much health it has left every time it is damaged."=
	[
		0 : "No"
		1 : "Yes"
	]

   // Inputs
   input Ignite(void) : "Ignite, burst into flames."
   input IgniteLifetime(float) : "Ignite, with a parameter lifetime."
   input IgniteNumHitboxFires(integer) : "Ignite, with a parameternumber of hitbox fires."
   input IgniteHitboxFireScale(float) : "Ignite, with a parameter hitbox fire scale."

	// Add the bullet penetration prevention flag
	spawnflags(flags)  =
	[
		32768: "GES: Disable Penetration" : 0
	]
]

@PointClass base(prop_physics) studioprop() sphere(fademindist) sphere(fademaxdist) = prop_physics_multiplayer :
	"This class is the same as prop_physics, except the runtime collisions use a more bouncy method that avoids " +
	"the prediction errors normal physics objects get."
[

	ShouldTint(choices) : "Damage Tint" : 1 : "Should the prop darken with relation to how much health it has left every time it is damaged."=
	[
		0 : "No"
		1 : "Yes"
	]

	physicsmode(choices) : "Physics Mode" : 0 =
	[
		0: "Auto Detect"
		1: "Solid, Server-side"
		2: "Non-Solid, Server-side"
		3: "Non-Solid, Client-side"
	]
	
	// Add the bullet penetration prevention flag
	spawnflags(flags)  =
	[
		32768: "GES: Disable Penetration" : 0
	]
]

@PointClass base(prop_dynamic) studioprop() sphere(fademindist) sphere(fademaxdist) = prop_ge_dynamic :
	"Just prop_dynamic with more options"
[
	HealthOverride(integer) : "Health Override" : -1 : "If set to non-negative value this will overwrite the model specified health."
	BreakHealth(integer) : "Health to Break" : 0 : "The health level the prop must drop below to switch to one of the broken skins.  Set to 0 break on first hit."
	BrokenSkinCount(integer) : "Broken Skin Count" : 0 : "The amount of possible broken skins the prop has.  Setting higher than 0 means the prop will pick a random one of the first x skins when broken."
	UseRandomSkins(choices) : "Use Random Skins" : 1 : "If set to yes, the prop will pick a random non-broken skin each time it spawns."=
	[
		0 : "No"
		1 : "Yes"
	]
	ShouldTint(choices) : "Damage Tint" : 1 : "Should the prop darken with relation to how much health it has left every time it is damaged."=
	[
		0 : "No"
		1 : "Yes"
	]
	RobustSpawn(choices) : "Robust Respawn" : 0 : "Checks for entities in the respawn area before respawning.  Props with any chance of spawning on top of a player should have this enabled."=
	[
		0 : "No"
		1 : "Yes"
	]
	PlCollide(choices) : "Player Collide" : 1 : "Sets the collision group to the debris group, so the prop won't collide with players but can still be shot." =
	[
		0 : "No"
		1 : "Yes"
	]
	DamageTransferTarget(target_destination) : "Damage Transfer Target" : : "Entity that will share taken damage with this one."
	RespawnTime(float) : "Respawn Time" : 20 : "Time it takes to attempt respawn after breaking."
	
	input PickRandomSkin(void) : "Pick an appropriate random skin."
	input PickRandomBrokenSkin(void) : "Pick a random broken skin."
	input PickRandomHealthySkin(void) : "Pick a random healthy skin."
	input Destroy(void) : "Force the entity to explode."
	input Respawn(void) : "Force the entity to respawn."
	
	output OnRespawn(void) : "Fires when the prop respawns."
]

@SolidClass base(func_breakable, BreakableBrush, Origin, RenderFields, Shadow) = func_rebreakable : 
	"A Respawnable brush entity that can be broken from damage, or an input."
[
	RespawnTime(float) : "Respawn Time" : 20 : "Amount in seconds this prop will respawn after it breaks."
]
@SolidClass quadbounds() base(func_breakable_surf) = func_rebreakable_surf : 
	"A breakable surface, that respawns, for partially breakable glass / tile / etc.  All faces but the desired visible one must be marked as NODRAW and that" +
	"face must be 4 sided.  The material applied to the visible face must be set up to be breakable." 
[
	RespawnTime(float) : "Respawn Time" : 20 : "Amount in seconds this prop will respawn after it breaks."
]

@SolidClass base(func_door, Origin, RenderFields, Shadow) = func_ge_door : 
	"A special door that can accelerate and have a partner."
[
	AccelerationTime(float) : "Acceleration Time" : 1 : "Amount of seconds it takes the door to get to top speed."
	AccelerationSpeed(float) : "Acceleration Speed" : 0 : "How fast the door will accelerate.  Overrides AccelerationTime if not set to 0."
	MinimumSpeed(float) : "Minimum Speed" : 1 : "Speed that the door will stop decelerating at during its final deceleration phase.  Does not affect direction changes, only the door's speed when nearing its destination.  Set higher for doors that you want to slam shut.  Setting too high can cause weird effects.  0 is best for double doors."
	ThinkInterval(float) : "Think Interval" : "0.1" : "How often the door calculates velocity.  Smaller values give smoother movement but are more costly."
	UseLimit(integer) : "Use Limit" : 3 : "How many times the door can be used during a single move cycle before it starts ignoring inputs.  ALWAYS SET TO ODD NUMBER TO AVOID DOOR ABUSE."
	TriggerThreshold(float) : "Trigger Threshold" : "0.5" : "Fraction of total movedistance that, when passed, triggers the OnPassThreshold outputs."
	PartnerDoor(target_destination) : "Partner Door" : : "Door that opens and closes with this one."

	input ForceToggle(void) : "Toggle the door, ignoring uselimit and locked conditions"
	input CheckMoveState(integer) : "Check the movestate of this door against the input, and fire OnMoveCheckPassed if it matches or OnMoveCheckFailed if it does not.  0 is open, 1 is closed, 2 is opening, 3 is closing."
	input CheckPartnersMoveState(integer) : "Same as CheckMoveState, but checks all of the doors partners as well.  If even one fails the check the check fires the false output."

	output OnFirstOpen(void)		: "Fires when the door is opened from rest"
	output OnFirstClose(void)		: "Fires when the door is closed from rest"
	output OnCrossThreshold(void)		: "Fires when the door passes its user designated Trigger Threshold"
	output OnCrossToThresholdFarSide(void)	: "Fires when the door passes its threshold from the near side to the far side"
	output OnCrossToThresholdNearSide(void)	: "Fires when the door passes its threshold from the far side to the near side"
	
	output OnAllPartnersOpened(void)	: "Fires when the last door in a partner chain hits the fully open position"
	output OnAllPartnersClosed(void)	: "Fires when the last door in a partner chain hits the fully closed position"
	output OnMoveCheckPassed(void)		: "Fires when a CheckMoveState or CheckPartnersMoveState returns true."
	output OnMoveCheckFailed(void)		: "Fires when a CheckMoveState or CheckPartnersMoveState returns false."
	
	spawnflags(flags)  =
	[
		131072: "Lock Sound Origin" : 0
	]
]

@SolidClass base(func_ge_door, Origin, Angles) = func_ge_door_rotating : 
	"The rotating variant of ge_door." 
[
	spawnflags(flags) =
	[
		2 : "Reverse Dir" : 0
		16: "One-way" : 0
		64: "X Axis" : 0
		128: "Y Axis" : 0
		65536: "New func_door +USE rules (NOT for prop_doors!!)" : 0
	]
	distance(integer) : "Distance" : 90 : "The amount, in degrees, that the button should rotate when it's pressed."

	solidbsp(choices) : "Solid Type" : 0 =
	[
		0 : "VPhysics"	
		1 : "BSP"
	]
]

@SolidClass base(func_brush, Origin, RenderFields, Shadow) = func_ge_brush : 
	"A special func_brush that can use any collision group."
[
	CollisionGroup(choices) : "Collision Group" : 0 : "What collision group should the brush be in?" =
	[
		0 : "NONE(Collides with everything)"
		1 : "DEBRIS"
		2 : "DEBRIS_TRIGGER"
		3 : "INTERACTIVE_DEBRIS"
		4 : "INTERACTIVE"
		5 : "PLAYER"
		6 : "BREAKABLE_GLASS"
		7 : "VEHICLE"
		8 : "PLAYER_MOVEMENT"
		9 : "NPC"
		10 : "IN_VEHICLE"
		11 : "WEAPON"
		12 : "VEHICLE_CLIP"
		13 : "PROJECTILE"
		14 : "DOOR_BLOCKER"
		15 : "PASSABLE_DOOR"
		16 : "DISSOLVING"
		17 : "PUSHAWAY"
		18 : "NPC_ACTOR"
		19 : "NPC_SCRIPTED"
		20 : "MINE"
		21 : "GRENADE"
		22 : "TKNIFE"
		23 : "DROPPEDWEAPON"
		24 : "BLOCKWEAPONS"
		25 : "CAPAREA"
		26 : "MI6"
		27 : "JANUS"
	]

	input SetCollideGroup(integer) : "Set the collision group of the brush.  Refer to the CollisionGroup choices for which integer to use for input."
	
	spawnflags(flags)  =
	[
		4: "Remove Touching" : 0
		8: "Robust Remove Checks" : 1
		16: "Use VPhysics for Remove Checks" : 0
	]
]

@SolidClass base(trigger_hurt, Origin, Angles) = trigger_trap : 
	"A hurt trigger that gives kill credit to its owner.  Firing Enable, Disable, Toggle, and BecomeOwner all transfer ownership."
[
	DeathMessage(target_destination) : "Death Message" : : "Message that is displayed when this trap gets a kill with no owner.  The victim's name is appended to the start."
	SuicideMessage(target_destination) : "Suicide Message" : : "Message that is displayed when the owner of the trap dies to it.  The victim's name is appended to the start."
	KillMessage(target_destination) : "Kill Message" : : "Message that is displayed when the trap gets a kill for its owner.  The killer is appended to the start.  Use 'player2' where you want the victim's name to appear."

	input SetDeathMessage(string) : "Sets the message displayed when the trap gets a kill with no owner."
	input SetSuicideMessage(string) : "Sets the message displayed when the trap gets a kill on its owner."
	input SetKillMessage(string) : "Sets the message displayed when the trap gets a kill for its owner."
		
	
	input BecomeOwner(void) : "Makes the activator of this input the owner of the trap."
	input VoidOwner(void) : "Sets the owner of the trap to no-one."
]

//-------------
// Items
//-------------
@BaseClass color(0 0 200) base(Targetname, Angles, Shadow) = Item
[
	output OnPlayerTouch(void) : "Fires when the player touches this object"
]

@PointClass base(Item, EnableDisable) studio("models/weapons/armor/armor.mdl")= item_armorvest :  "Armor Vest"
[
	input Toggle(void) : "Toggle this spawner on/off"
	CheckRadius(integer) : "Check Radius" : 512 : "How far the armor looks for players when determining if it should spawn.  For really big rooms this should be higher, for really small rooms it should be lower.  The radius should extend to the edge of the area the armor camper could easily control.  It should not include any areas he cannot easily contest."
]

@PointClass base(Item, EnableDisable) studio("models/weapons/halfarmor/halfarmor.mdl")= item_armorvest_half :  "Armor Vest (50%)"
[
	input Toggle(void) : "Toggle this spawner on/off"
]

//----------------
// Block Entity
//----------------
@SolidClass base(Targetname) = func_blockedge: "if sv_blockedges == 1, this will turn into a solid"
[
]

//----------------
// Utility
//----------------

@PointClass base(Targetname) = ge_point_follower : 
	"Point entity that follows other entities.  Just parent something to it if you want a prop or brush structure to smoothly interpolate to something."
[
	TargetEnt(target_destination) : "Target Entity" : : "The entity that this follows around."
	InterpInterval(float) : "Interpolation Interval" : "0.1" : "Amount of time between the intervals it interpolates between."
]

@PointClass base(Targetname) = ge_door_interp : 
	"Point entity that mimics a given door's movement pattern.  Used to eliminate client side jitter on less-than-perfect connections for stuff like elevators."
[
	TargetDoor(target_destination) : "Door To Mimic" : : "The door we want this entity to predict."
	AccelDampener(float) : "Acceleration Coefficient" : "0.8" : "Multiplier on the target door's acceleration in order to correct for weird sinking nonsense."
	MoveDelay(float) : "Start Move Delay" : "0.1" : "Delay between getting the activation signal and starting to move.  Also used for sinking correction."	
]

@PointClass iconsprite("editor/logicgate.vmt") base(Targetname) = ge_logic_gate : 
	"Logic entity that can behave as any of the basic logic gates."
[
	GateType(choices) : "Gate Type" : 0 : "Which logic should this gate use?" =
	[
		0 : "AND"
		1 : "OR"
		2 : "NAND"
		3 : "NOR"
		4 : "XOR"
		5 : "XNOR"
		6 : "NOT(X only)"
	]
	ShouldAutoFire(choices) : "Should Fire on Value Change" : 1 : "Should this gate fire an output every time the input changes?" =
	[
		0 : "No"
		1 : "Yes"
	]
	StartingXValue(choices) : "Initial X Value" : 0 : "What value does X start at?" =
	[
		0 : "False"
		1 : "True"
	]
	StartingYValue(choices) : "Initial Y Value" : 0 : "What value does X start at?" =
	[
		0 : "False"
		1 : "True"
	]	
	
	// Inputs

	input SetGateType(integer) : "Set the type of logic this gate uses.  0 is AND, 1 is OR, 2 is NAND, 3 is NOR, 4 is XOR, 5 is XNOR, 6 is NOT."
	input TestOutput(void) : "Check the output of the gate and fire FireTrue if it's true and FireFalse if it's false."
	
	input SetXTrue(void) : "Set the X input to true"
	input SetYTrue(void) : "Set the Y input to true"
	input SetXFalse(void) : "Set the X input to false"
	input SetYFalse(void) : "Set the Y input to false"

	input ToggleX(void) : "Toggle the X input from true to false or from false to true"	
	input ToggleY(void) : "Toggle the Y input from true to false or from false to true"	
	
	input EnableAutofire(void) : "Enable autofire behaviour"	
	input DisableAutofire(void) : "Disable autofire behaviour"	
	
	output OnFireTrue(void)		: "Fires when the given logic gate would fire true with the current inputs."
	output OnFireFalse(void)	: "Fires when the given logic gate would fire false with the current inputs."
]

@PointClass iconsprite("editor/logicbitflag.vmt") base(Targetname) = ge_logic_bitflag : 
	"Logic entity that holds a single bit and remembers its state between rounds."
[
	StartingState(choices) : "Initial Value" : 0 : "What value does the bit start at?  Keep in mind that this is applied ONLY on level load and not round start like most other entities.  If you need a bitflag that resets each round, use ge_logic_gate set to AND with one input set permanently to true.  The other input is your flag." =
	[
		0 : "False"
		1 : "True"
	]	
	
	// Inputs	
	input SetStateTrue(void) : "Sets the state to true"
	input SetStateFalse(void) : "Sets the state to false"
	input ToggleState(void) : "Toggles the state"
	
	input CheckState(void) : "Checks the state and fires the appropriate output"
	
	input SetFalseCheck(void) : "Set the state to false and then fire the false output"
	input SetTrueCheck(void) : "Set the state to true and then fire the true output"
	input ToggleCheck(void) : "Toggle the state and then fire the output of the new state"
	
	output OnFireTrue(void)		: "Fires when the bit is tested while true."
	output OnFireFalse(void)	: "Fires when the bit is tested while false."
]

//----------------
// GE SPAWNERS
//----------------

@BaseClass color(0 0 200) base(Targetname, Angles, EnableDisable, Targetname) = Spawner
[
	input Toggle(void) : "Toggle this spawner on/off"
	
	output OnPickedUp(void)	: "Fires when someone picks up a token that spawned here."
	output OnRespawn(void)	: "Fires when a token spawns here."
]

@PointClass iconsprite("editor/tokenspawner.vmt") base(Spawner) = ge_tokenspawner : "GES Gameplay Token Spawner to define specific spots to spawn gameplay tokens "
	+ " (Flags, Keys, etc)"
[
]

@PointClass iconsprite("editor/tokenspawnerMI6.vmt") base(Spawner) = ge_tokenspawner_mi6 : "GES Gameplay Token Spawner to define specific spots to spawn gameplay tokens "
	+ " for MI6 team (Flags, Keys, etc)"
[
]

@PointClass iconsprite("editor/tokenspawnerjanus.vmt") base(Spawner) = ge_tokenspawner_janus : "GES Gameplay Token Spawner to define specific spots to spawn gameplay tokens "
	+ " for Janus team (Flags, Keys, etc)"
[
]

@PointClass iconsprite("editor/capturearea.vmt") base(Spawner) = ge_capturearea_spawn : "GES Gameplay Capture Area spawn to define specific spots to spawn token capture areas."
[
]

@PointClass iconsprite("editor/captureareaMI6.vmt") base(Spawner) = ge_capturearea_spawn_mi6 : "GES Gameplay Capture Area spawn to define specific spots to spawn token capture areas."
[
]

@PointClass iconsprite("editor/captureareajanus.vmt") base(Spawner) = ge_capturearea_spawn_janus : "GES Gameplay Capture Area spawn to define specific spots to spawn token capture areas."
[
]

@PointClass base(Spawner) studio() = ge_weaponspawner : "GES Weapon Spawner (uses weapon loadouts)."
[
	model(studio) : "Hammer View" : "models/editor/weaponspawner.mdl" : "Set this for a visual reference **IN HAMMER**"
	allowgg(choices) : "Allow Tokens" : 0 =
	[
		0 : "No"
		1 : "Yes"
	]
	skin(choices) : "skin" : 7 =
	[
		7 : "1 - Lowest Strength"
		0 : "2"
		1 : "3"
		2 : "4"
		3 : "5"
		4 : "6"
		5 : "7"
		6 : "8 - Highest Strength"
	]
	slot(choices) : "Weapon Slot" : 0 =
	[
		0 : "1 - Lowest Strength"
		1 : "2"
		2 : "3"
		3 : "4"
		4 : "5"
		5 : "6"
		6 : "7"
		7 : "8 - Highest Strength"
		8 : "OVERRIDE ONLY"
	]
]
@PointClass base(Spawner) studio() = ge_ammospawner : "GES Ammo Spawner"
[	
	model(studio) : "Hammer View" : "models/weapons/ammocrate.mdl" : "Set this for a visual reference **IN HAMMER**"
	slot(choices) : "Weapon Slot" : 0 =
	[
		0 : "1 - Lowest Strength"
		1 : "2"
		2 : "3"
		3 : "4"
		4 : "5"
		5 : "6"
		6 : "7"
		7 : "8 - Highest Strength"
	]
]

//-------------------------------------------------------------------------
// Camera/monitor entities from halflife2.fgd
//-------------------------------------------------------------------------
@PointClass base(Parentname, Angles) studioprop("models/editor/camera.mdl") = point_camera : "Camera"
[
	spawnflags(Flags) =
	[
		1 : "Start Off" : 0 
	]

	targetname(target_source) : "Name" : : "The name that other entities refer to this entity by."
	FOV(float) : "FOV" : 90 : "Field of view in degrees"
//	resolution(float) : "resolution" : 256 : "width/height of the render target for the camera"
	UseScreenAspectRatio(choices) : "Screen Aspect Ratio" : 0 =
	[
		0 : "No"
		1 : "Yes"
	]	
	fogEnable(choices) : "Fog Enable" : 0 =
	[
		0 : "No"
		1 : "Yes"
	]	
	fogColor(color255) : "Fog Color" : "0 0 0"
	fogStart(float) : "Fog Start" : 2048 : "The near fog plane."
	fogEnd(float) : "Fog End" : 4096 : "The far fog/clipping plane."

	// Inputs
	input ChangeFOV(string) : "Changes camera's FOV over time"
	input SetOnAndTurnOthersOff(void) : "Turn the camera on, and turn all other cameras off."
	input SetOn(void) : "Turn the camera on."
	input SetOff(void) : "Turn the camera off."
]

@SolidClass base(func_brush) = func_monitor :
	"A monitor that renders the view from a given point_camera entity."
[
	target(target_destination) : "Camera name"
	
	// Inputs
	input Toggle(void) : "Toggle - If on, turn off, if off, turn on."
	input Enable(void) : "Enable."
	input Disable(void) : "Disable."
	input SetCamera(string) : "Sets the camera to use for this monitor. Takes the name of a point_camera entity in the map."
]

// END CAMERA STUFF


//-------------------------------------------------------------------------
//
// Camera/monitor entities
//
//-------------------------------------------------------------------------
@PointClass base(Parentname, Angles) studioprop("models/editor/camera.mdl") = point_camera : "Camera"
[
	spawnflags(Flags) =
	[
		1 : "Start Off" : 0 
	]

	targetname(target_source) : "Name" : : "The name that other entities refer to this entity by."
	FOV(float) : "FOV" : 90 : "Field of view in degrees"
//	resolution(float) : "resolution" : 256 : "width/height of the render target for the camera"
	UseScreenAspectRatio(choices) : "Screen Aspect Ratio" : 0 =
	[
		0 : "No"
		1 : "Yes"
	]	
	fogEnable(choices) : "Fog Enable" : 0 =
	[
		0 : "No"
		1 : "Yes"
	]	
	fogColor(color255) : "Fog Color" : "0 0 0"
	fogStart(float) : "Fog Start" : 2048 : "The near fog plane."
	fogEnd(float) : "Fog End" : 4096 : "The far fog/clipping plane."
	renderTarget(string) : "Render Target" : "_rt_Camera" : "The render target of the camera."

	// Inputs
	input ChangeFOV(string) : "Changes camera's FOV over time"
	input SetOnAndTurnOthersOff(void) : "Turn the camera on, and turn all other cameras off."
	input SetOn(void) : "Turn the camera on."
	input SetOff(void) : "Turn the camera off."
]
